# -*- coding: utf-8 -*-
from django.db import models
from django.contrib.auth.models import User
from django.utils.translation import ugettext_lazy as _
from datetime import date, datetime
import string
from django.core.exceptions import ValidationError
from utils import make_new_uid


# class TaskGroup(models.Model):
#     hospital = models.ForeignKey("Hospital", verbose_name=_("Hospital"))
#     title = models.CharField(_("Title"), max_length=100, unique=True)
#     department = models.CharField(_("Department"), max_length=200, help_text=_("Referred department (e.g. \"Patologia Cardiaca\")"))
#     task_group_type = models.CharField(_("Task group type"), max_length=50, null=True, blank=True, help_text=_("The S.S.D. (e.g. \"Patologia Cardiaca\")"))
#     secretariat_phone = models.CharField(_("Secretariat phone"), max_length=50, null=True, blank=True)
#     secretariat_fax = models.CharField(_("Secretariat fax"), max_length=50, null=True, blank=True)
#     director = models.CharField(_("Director"), max_length=150)
#     head_office_phone = models.CharField(_("Head office phone"), max_length=50, null=True, blank=True)
#     head_office_email = models.EmailField(_("Head office email"), null=True, blank=True)
#     tc_service = models.BooleanField(_("Offers teleconsultation service?"),
#         help_text=_("select if the task group offers an teleconsultation service"), default=False)
#     is_active = models.BooleanField(_("Is active?"), default=True)
#     devices = models.ManyToManyField(Device, verbose_name=_("Devices"), related_name="taskgroups", null=True, blank=True)
#     description = models.TextField(_("Description"))
#
#     def __unicode__(self):
#         return u"[%s]" % self.title # TaskGroup: %s" % (self.title, self.description)
#
#     def get_absolute_url(self):
#         return "/task_group/%i/get/" % self.id
#
#     def get_fields():
#         mandatory = ["title", ]
#         optional = []
#         return (mandatory, optional)
#
#     def clean(self):
#         if self.duty_calendar:
#             if self.duty_calendar.kind != 2: # Il tipo deve essere per forza un Duty
#                 raise ValidationError(_("Duty Calendar admits only \"duty calendar\" type!"))
#
#     class Meta:
#         #db_table = "task_group"
#         verbose_name = _("Task Group")
#         verbose_name_plural = _("Task Groups")
#
#     def save(self, *args, **kwargs):
#         super(TaskGroup, self).save(*args, **kwargs)
#         if not self.pk:
#             self.duty_calendar = Calendar.objects.create(title=_("Duty calendar %s" % self.__unicode__()),
#                         desc=_("(DUTY) calendar internal of task group %s" % self.__unicode__()),
#                         kind=2,
#                         color=3,
#                         owner_task_group=self,
#                         is_active=True
#             )
#             self.save()


class UserProfile(models.Model):
    """Class UserProfile

    Attributes:
        uid                     (django.db.models.CharField)        : autogenerated unique identification number
        user                    (django.contrib.auth.models.User)   : predefined django user model
        numeric_password    (   django.db.models.CharField)         : numeric password (for app login purpose)
        user_type               (django.db.models.CharField)        : user type
        gender                  (django.db.models.CharField)        : user gender
        phone                   (django.db.models.CharField)        : user phone number
        mobile                  (django.db.models.CharField)        : user mobile phone number
        certified_email         (django.db.models.EmailField)       : user certified email
        creation_timestamp      (django.db.models.DateTimeField)    : user creation timestamp
        last_modified_timestamp (django.db.models.DateTimeField)    : user last modification timestamp
        deactivation_timestamp  (django.db.models.DateTimeField)    : user deactivation timestamp
        is_health_care_provider  (django.db.models.DateTimeField)    : clinician enabled to play specialized role
    """
    USER_TYPES = (
        ('AD', _('Administrative')),
        ('TE', _('Technician')),
        ('CL', _('Clinician')),
        ('ST', _('Student')),
    )
    GENDER_CHOICES = (
        ('M', _('Male')),
        ('F', _('Female')),
        ('U', _('Unknown')),
    )

    uid = models.CharField(max_length=40, default=make_new_uid, unique=True)
    user = models.ForeignKey(User)
    numeric_password = models.CharField(max_length=4, null=True, blank=True, verbose_name=_('Numeric password'),
                                        help_text=_('4 numbers code'))
    user_type = models.CharField(_('User type'), choices=USER_TYPES, max_length=2)
    gender = models.CharField(_('Gender'), max_length=1, choices=GENDER_CHOICES, default='U')
    phone = models.CharField(_('Phone'), max_length=20, null=True, blank=True)  # TODO: validation rules
    mobile = models.CharField(_('Mobile phone'), max_length=20, null=True, blank=True)  # TODO: validation rules
    certified_email = models.EmailField(_('Certified email'), null=True, blank=True)
    creation_timestamp = models.DateTimeField(auto_now_add=True)
    last_modified_timestamp = models.DateTimeField(auto_now=True)
    deactivation_timestamp = models.DateTimeField(null=True, blank=True, default=None)
    # task_group = models.ForeignKey("medicalrecords.TaskGroup", verbose_name=_("Task group"), related_name="user_task_group", db_column="task_group_id")
    # role = models.CharField(_('Role'), choices=ROLES, max_length=2, null=True, blank=True)
    # logged_role = models.CharField(_('Logged role'), help_text=_('Only for clinicians users'), choices=ROLES, max_length=2, null=True, blank=True)
    # sip_account = models.OneToOneField(SipAccount, verbose_name=_('Sip account'), null=True, blank=True)
    # related_task_group = models.ManyToManyField('medicalrecords.TaskGroup', help_text=_('The task groups related a specialist unit (only for specialist TG)'), verbose_name=_('Related task group'), related_name='authorized_specs', blank=True, null=True)

    def get_full_name(self):
        return u'%s %s [%s]' % (self.last_name, self.first_name, self.get_user_type_display())

    def get_short_name(self):
        return u'%s [%s]' % (self.user.username, self.user_type)

    def __unicode__(self):
        return u'%s %s' % (self.last_name, self.first_name)

    def clean(self):
        # If is_health_care_provider == True and clinician_type != 'DO', raise exception
        if not (self.numeric_password.isdigit() and len(self.numeric_password) == 4):
            raise ValidationError(_('Numeric password has to be 4 digit number.'))

    class Meta:
        db_table = "user_profile"
        verbose_name = _("MOST User")
        verbose_name_plural = _("MOST Users")


class ClinicianUserProfile(models.Model):
    """Class ClinicianUserProfile

    Attributes:
        user_profile        (django.db.models.ForeignKey :: UserProfile)    : numeric password (for app login purpose)
        clinician_type      (django.db.models.CharField)                    : clinician type
        specialization      (django.db.models.CharField)                    : clinical specialization
    """
    CLINICIAN_TYPES = (
        ('DR', _('Doctor')),
        ('OP', _('Operator')),
    )

    user_profile = models.ForeignKey('UserProfile')
    clinician_type = models.CharField(_('Clinician type'), choices=CLINICIAN_TYPES, max_length=2)
    specialization = models.CharField(_('Clinical specialization'), null=True, blank=True, max_length=50)
    # If is_health_care_provider == True and clinician_type == 'DO', it can play the specialized role
    is_health_care_provider = models.BooleanField(_('Is health care provider?'), default=True)

    def get_full_name(self):
        full_name = u'[%s] %s' % (self.clinician_type, self.user_profile)
        if self.specialization:
            full_name += u'- %s' % self.specialization
        return full_name

    def __unicode__(self):
        clinician_string = u'%s %s' % (self.get_clinician_type_display(), self.user_profile)
        if self.specialization:
            clinician_string += u' (%s)' % self.specialization
        if self.is_health_care_provider:
            clinician_string += u' - Provider'
        return clinician_string

    def clean(self):
        # If is_health_care_provider == True and clinician_type != 'DO', raise exception
        if not self.clinician_type == 'DO' and self.is_health_care_provider:
            raise ValidationError(_('Only doctors can provide health care service'))

    class Meta:
        db_table = "clinician_user"
        verbose_name = _("MOST Clinician User")
        verbose_name_plural = _("MOST Clinician Users")

# from django.db import models
# from django.contrib.auth.models import User, UserManager
# from django.core.exceptions import ValidationError
# from remote.common.utilities import make_new_uid
# from remote.sip.views import create_sip_account
# from remote.sip.models import Sip, Extensions, Credentials
# from remote.settings import DEFAULT_LANG, TURN_ADDRESS, SIP_ADDRESS
# from django.utils.translation import ugettext, ugettext_lazy as _
#
# TYPES_USER = (
#         ("AD", _('ADMINISTRATIVE')),
#         ("TE", _('TECHNICAL')),
#         ("CL", _('CLINICIAN')),
#         ("DI", _('DIDACTIC')),
# )
#
# # only for clinician users
# ROLES = (
#         ("SP", _('SPECIALIST')),
#         ("AP", _('APPLICANT')),
#         ("SU", _('SUPER SPECIALIST')),
# )
#
# # Translated languages for user. If add new language -> add also in main_viewport.js
# TRANSLATED_LANGUAGES = (
#          ('it', _('Italiano')),
#          ('en', _('English')),
# )
#
# class UserLanguage(models.Model):
#     user = models.ForeignKey("UserProfile", null=False, blank=False, unique=True)
#     lang = models.CharField(_("Language"), choices=TRANSLATED_LANGUAGES, default=DEFAULT_LANG, max_length=2, null=False, blank=False)
#
#     def __unicode__(self):
#         return u'%s set to %s' % (self.user, self.lang)
#
#     def get_lang(self):
#         return self.lang
#
#     class Meta:
#         db_table = "user_language"
#         verbose_name = _("User Language")
#         verbose_name_plural = _("Users Languages")
#
# class UserState(models.Model):
#     state = models.CharField(_("state"), max_length=20, null=False, blank=False, unique=True)
#
#     def __unicode__(self):
#         return u'%s' % self.state
#
#     class Meta:
#         db_table = "user_state"
#         verbose_name = _("User State")
#         verbose_name_plural = _("User States")
#
#
# class SipAccount(models.Model):
#     uid = models.CharField(max_length=40, default=make_new_uid, unique=True)
#     sip = models.ForeignKey("sip.Sip", verbose_name=_("Sip"))
#     extensions = models.ForeignKey(Extensions, verbose_name=_("Extensions"))
#     credentials = models.ForeignKey(Credentials, verbose_name=_("Credentials"))
#     #Nella view che restituisce i dati alle app mandiamo gli indirizzi del file di settings.py
#     """
#     sip_server = models.CharField(_("Sip server"), default=SIP_ADDRESS, max_length=100)
#     turn_server = models.CharField(_("Turn server"), default=TURN_ADDRESS, max_length=100)
#
#     sip_user = models.CharField(_("Sip user"), max_length=50)
#     sip_pwd = models.CharField(_("Sip password"), max_length=50)
#     sip_extension = models.CharField(_("Sip extension"), max_length=50)
#     sip_server = models.CharField(_("Sip server"), max_length=100)
#     turn_server = models.CharField(_("Turn server"), max_length=100)
#     turn_user = models.CharField(_("Turn user"), max_length=100)
#     turn_pwd = models.CharField(_("Turn password"), max_length=100)
#     """
#     def __unicode__(self):
#         return u"%s - %s" % (self.sip, self.extensions)
#
#     class Meta:
#         verbose_name = _("Sip account")
#         verbose_name_plural = _("Sip accounts")
#
#     """def save(self, *args, **kwargs):
#         pass"""
#
# class UserProfile(User): #models.Model): #
#     #refers to a model not yet created -> https://docs.djangoproject.com/en/dev/ref/models/fields/#foreignkey
#     uid = models.CharField(max_length=40, default=make_new_uid, unique=True)
#     numeric_password = models.BigIntegerField(_("Numeric password"), null=True, blank=True, help_text=_("4 numbers (only for clinicians)"))
#     task_group = models.ForeignKey("medicalrecords.TaskGroup", verbose_name=_("Task group"), related_name="user_task_group", db_column="task_group_id")
#     state = models.ForeignKey(UserState, verbose_name=_("Stato"), null=True, blank=True, db_column="state_id")
#     specialization = models.CharField(_("Specialization"), null=True, blank=True, max_length=100)
#     phone = models.CharField(_("Phone"), max_length=20)
#     sex = models.CharField(_("Gender"), max_length=1, null=True, blank=True, choices=(('M', _('Male')), ('F', _('Female'))))
#     type_user = models.CharField(_("Type user"), choices=TYPES_USER, max_length=2)
#     role = models.CharField(_("Role"), choices=ROLES, max_length=2, null=True, blank=True)
#     logged_role = models.CharField(_("Logged role"), help_text=_("Only for clinicians users"), choices=ROLES, max_length=2, null=True, blank=True)
#     sip_account = models.OneToOneField(SipAccount, verbose_name=_("Sip account"), null=True, blank=True)
#     related_task_group = models.ManyToManyField("medicalrecords.TaskGroup", help_text=_("The task groups related a specialist unit (only for specialist TG)"), verbose_name=_("Related task group"), related_name="authorized_specs", blank=True, null=True)
#
#     objects = UserManager()
#
#     def __unicode__(self):
#         return u"%s %s" % (self.username, self.task_group)
#
#     def get_user_logged(self):
#         return u"%s (%s %s)" % (self.username, self.first_name.title(), self.last_name.title())
#
#     def get_absolute_url(self):
#         return "/user_profile/%i/get/" % self.id
#
#     def get_fields():
#         mandatory = ["task_group", "state", "username", "password", "extension", "name", "surname", "email", "cell", ]
#         optional = []
#         return (mandatory, optional)
#
#     def get_full_name(self):
#         return "%s %s (%s)" % (self.last_name, self.first_name, self.task_group.title)
#
#     def is_administrative(self):
#         if self.type_user == "AD":
#             return True
#         else:
#             return False
#
#     def get_utilities(self):
#         utilities = []
#         if self.type_user == "AD":
#             utilities.extend([
#                 "CalendarManager",
#                 "PatientManager",
#                 "UsersManager"
#                 "Statistics"
#             ])
#         elif self.type_user == "CL":
#             utilities.extend([
#                 "TeleconsultationManager",
#                 "CalendarManager",
#                 "PatientManager",
#                 "Medicalrecord",
#                 "Statistics"
#             ])
#         #elif user.type_user == "TE":
#         return utilities
#
#     class Meta:
#         db_table = "user_profile"
#         verbose_name = _("User Remote")
#         verbose_name_plural = _("Users Remote")
#
#     def clean(self):
#         # if the TG is not specialistic the role admitted is only applicant or didactic
#         if not self.task_group.tc_service and self.role == "SP":
#             raise ValidationError(_("The task group %s don't admits a specialistic role!") % self.task_group)
#         if not self.task_group.tc_service and self.role == "SU":
#             raise ValidationError(_("The task group %s don't admits a super specialistic role!") % self.task_group)
#         # the role is admit only for clinicians
#         if self.type_user != "CL" and self.role:
#             raise ValidationError(_("The role is admit only for clinician type of user!"))
#         # role required for clinicians
#         if self.type_user == "CL" and not self.role:
#             raise ValidationError(_("The role is required for clinicians!"))
#         # SipAccount is valid only for Cinicians and not didactic roles
#         if self.type_user != "CL" and self.sip_account:
#             raise ValidationError(_("Only clinician can have a SIP account!"))
#         if self.numeric_password and self.type_user != "CL": # or (self.role != "AP" and self.role != "SP")):
#             raise ValidationError(_("Only clinician applicant/specialist admits a numeric password!"))
#         if self.numeric_password :
#             if len(str(self.numeric_password)) != 4:
#                 raise ValidationError(_("The numeric password has 4 numbers!"))
# #        # Only clinician specialist admits a related_task_group
# #        if self.type_user != "CL" and self.related_task_group:
# #            raise ValidationError(_("Only clinicians specialist (or super specialist) admits a related_task_group!"))
# #        elif self.type_user == "CL":
# #            if self.role != "SP" or self.role != "SU":
# #                raise ValidationError(_("Only clinicians specialist (or super specialist) admits a related_task_group!"))
#
#     def save(self, *args, **kwargs):
#         if self.type_user == "TE":
#             #self.is_stuff = True
#             self.is_staff = True
#             # QUA BISOGNA AGGIUNGERE TUTTI I PERMESSI NECESSARI AL TECNICO!
#         elif self.type_user == "CL":
#             if not self.pk:
#                 # verifichiamo che sia il primo inserimento dell'utente clinico
#                 self.logged_role = self.role
#                 # creo l'account sip associato
#                 sip, extensions, credentials = create_sip_account(self)
#                 sip_account = SipAccount.objects.create(sip=sip, extensions=extensions, credentials=credentials)
#                 self.sip_account = sip_account
#         super(UserProfile, self).save(*args, **kwargs)
